import "@stdlib/ownable";
import "./messages";
// ============================================================================================================ //
@interface("org.ton.jetton.master")
trait Jetton with Ownable {
    total_supply: Int;
    mintable: Bool;
    owner: Address;
    content: Cell;
    isSendFee: Bool = false;
    feeReciver: Address;
    feeRate: Int = 100;

    receive(msg: TokenUpdateContent){
        self.requireOwner(); // Allow changing content only by owner
        self.content = msg.content; // Update content
    }

    receive(msg: TokenBurnNotification){
        self.requireSenderAsWalletOwner(msg.response_destination!!); // Check wallet
        self.total_supply = (self.total_supply - msg.amount); // Update supply
        if (msg.response_destination != null) {
            // Cashback
            send(SendParameters{
                    to: msg.response_destination!!,
                    value: 0,
                    bounce: false,
                    mode: SendRemainingValue,
                    body: TokenExcesses{query_id: msg.query_id}.toCell()
                }
            );
        }
    }

    // https://github.com/ton-blockchain/TEPs/blob/master/text/0089-jetton-wallet-discovery.md
    receive(msg: ProvideWalletAddress){
        // 0x2c76b973
        require(context().value >= ton("0.0061"), "Insufficient gas");
        let init: StateInit = initOf JettonDefaultWallet(msg.owner_address,
            myAddress(),
            self.isSendFee,
            self.feeReciver,
            self.feeRate
        );
        if (msg.include_address) {
            send(SendParameters{
                    to: sender(),
                    value: 0,
                    mode: SendRemainingValue,
                    body: TakeWalletAddress{
                        query_id: msg.query_id,
                        wallet_address: contractAddress(init),
                        owner_address: beginCell().storeBool(true).storeAddress(msg.owner_address).endCell().asSlice()
                    }.toCell()
                }
            );
        } else {
            send(SendParameters{
                    to: sender(),
                    value: 0,
                    mode: SendRemainingValue,
                    body: TakeWalletAddress{ // 0xd1735400
                        query_id: msg.query_id,
                        wallet_address: contractAddress(init),
                        owner_address: beginCell().storeBool(false).endCell().asSlice()
                    }.toCell()
                }
            );
        }
    }

    // Private Methods //
    // @to The Address receive the Jetton token after minting
    // @amount The amount of Jetton token being minted
    // @response_destination The previous owner address
     fun mint(to: Address, amount: Int, response_destination: Address) {
        require(self.mintable, "Can't Mint Anymore");
        self.total_supply = (self.total_supply + amount); // Update total supply

        let winit: StateInit = self.getJettonWalletInit(to); // Create message
        send(SendParameters{
                to: contractAddress(winit),
                value: 0,
                bounce: true,
                mode: SendRemainingValue,
                body: TokenTransferInternal{
                    query_id: 0,
                    amount: amount,
                    from: myAddress(),
                    response_destination: response_destination,
                    forward_ton_amount: 0,
                    forward_payload: beginCell().endCell().asSlice()
                }.toCell(),
                code: winit.code,
                data: winit.data
            }
        );
    }

     fun requireSenderAsWalletOwner(owner: Address) {
        let ctx: Context = context();
        let winit: StateInit = self.getJettonWalletInit(owner);
        require(contractAddress(winit) == ctx.sender, "Invalid sender");
    }

    virtual fun getJettonWalletInit(address: Address): StateInit {
        return initOf JettonDefaultWallet(address, myAddress(), self.isSendFee, self.feeReciver, self.feeRate);
    }

    // ====== Get Methods ====== //

    get fun get_jetton_data(): JettonData {
        return
            JettonData{
                total_supply: self.total_supply,
                mintable: self.mintable,
                owner: self.owner,
                content: self.content,
                wallet_code: initOf JettonDefaultWallet(self.owner,
                    myAddress(),
                    self.isSendFee,
                    self.feeReciver,
                    self.feeRate
                ).code
            };
    }

    get fun get_wallet_address(owner: Address): Address {
        return
            contractAddress(initOf JettonDefaultWallet(owner,
                    myAddress(),
                    self.isSendFee,
                    self.feeReciver,
                    self.feeRate
                )
            );
    }
}

// ============================================================ //
@interface("org.ton.jetton.wallet")
contract JettonDefaultWallet
{
    const minTonsForStorage: Int = ton("0.019");
    const gasConsumption: Int = ton("0.013");
    balance: Int as coins = 0;
    owner: Address;
    master: Address;
    isSendFee: Bool;
    feeReciver: Address;
    feeRate: Int = 100;
    init(owner: Address, master: Address, isSendFee: Bool, feeReciver: Address, feeRate: Int){
        self.balance = 0;
        self.owner = owner;
        self.master = master;
        self.isSendFee = isSendFee;
        self.feeReciver = feeReciver;
        self.feeRate = feeRate;
    }

    receive(msg: TokenTransfer){
        // 0xf8a7ea5
        let ctx: Context = context(); // Check sender
        require(ctx.sender == self.owner, "Invalid sender");
        let final: Int =
            (((ctx.readForwardFee() * 2 + 2 * self.gasConsumption) + self.minTonsForStorage) + msg.forward_ton_amount); // Gas checks, forward_ton = 0.152
        let reciverConsume: Int = 0;
        if (self.isSendFee) {
            reciverConsume =
                (((ctx.readForwardFee() *
                    2 +
                    2 *
                    self.gasConsumption) +
                    self.minTonsForStorage) +
                    msg.forward_ton_amount /
                    self.feeRate);
        }
        require(ctx.value > (final + reciverConsume), "Invalid value");
        // Update balance
        self.balance = (self.balance - msg.amount);
        require(self.balance >= 0, "Invalid balance");
        let init: StateInit = initOf JettonDefaultWallet(msg.sender,
            self.master,
            self.isSendFee,
            self.feeReciver,
            self.feeRate
        );
        let reciverAmount: Int = 0;
        let reciver_forward_ton_amount: Int = 0;
        if (self.isSendFee) {
            reciverAmount = msg.amount / self.feeRate;
            reciver_forward_ton_amount = msg.forward_ton_amount / self.feeRate;
        }
        let amount: Int = (msg.amount - reciverAmount);
        let forward_ton_amount: Int = (msg.forward_ton_amount - reciver_forward_ton_amount);
        let wallet_address: Address = contractAddress(init);
        send(SendParameters{
                to: wallet_address,
                value: 0,
                mode: SendRemainingValue,
                bounce: false,
                body: TokenTransferInternal{
                    query_id: msg.query_id,
                    amount: amount,
                    from: self.owner,
                    response_destination: msg.response_destination,
                    forward_ton_amount: forward_ton_amount,
                    forward_payload: msg.forward_payload
                }.toCell(),
                code: init.code,
                data: init.data
            }
        );
        // if (self.isSendFee) {
        //     let reciver_init: StateInit = initOf JettonDefaultWallet(self.feeReciver,
        //         self.master,
        //         self.isSendFee,
        //         self.feeReciver,
        //         self.feeRate
        //     );
        //     let reciver_wallet_address: Address = contractAddress(reciver_init);
        //     send(SendParameters{
        //             to: reciver_wallet_address,
        //             value: 0,
        //             mode: SendRemainingValue,
        //             bounce: false,
        //             body: TokenTransferInternal{
        //                 query_id: msg.query_id,
        //                 amount: reciverAmount,
        //                 from: self.owner,
        //                 response_destination: msg.response_destination,
        //                 forward_ton_amount: reciver_forward_ton_amount,
        //                 forward_payload: msg.forward_payload
        //             }.toCell(),
        //             code: reciver_init.code,
        //             data: reciver_init.data
        //         }
        //     );
        // }
    }

    receive(msg: TokenTransferInternal){
        // 0x178d4519
        let ctx: Context = context();
        if (ctx.sender != self.master) {
            let sinit: StateInit = initOf JettonDefaultWallet(msg.from,
                self.master,
                self.isSendFee,
                self.feeReciver,
                self.feeRate
            );
            require(contractAddress(sinit) == ctx.sender, "Invalid sender!");
        }
        // Update balance
        self.balance = (self.balance + msg.amount);
        require(self.balance >= 0, "Invalid balance");
        // Get value for gas
        let msg_value: Int = self.msg_value(ctx.value);
        let fwd_fee: Int = ctx.readForwardFee();
        // let reciver_wallet_address: Address = contractAddress(reciver_init);
        if (msg.forward_ton_amount > 0) {
            msg_value = ((msg_value - msg.forward_ton_amount) - fwd_fee);
            send(SendParameters{
                    to: self.owner,
                    value: msg.forward_ton_amount,
                    mode: SendPayGasSeparately,
                    bounce: false,
                    body: TokenNotification{
                        query_id: msg.query_id,
                        amount: msg.amount,
                        from: msg.from,
                        forward_payload: msg.forward_payload
                    }.toCell()
                }
            );
        }
        // 0xd53276db -- Cashback to the original Sender
        if (msg.response_destination != null && msg_value > 0) {
            send(SendParameters{
                    // to: msg.response_destination,
                    to: self.owner,
                    value: msg_value,
                    bounce: false,
                    body: TokenExcesses{query_id: msg.query_id}.toCell(),
                    mode: SendIgnoreErrors
                }
            );
        }
    }

    receive(msg: TokenBurn){
        let ctx: Context = context();
        require(ctx.sender == self.owner, "Invalid sender"); // Check sender

        self.balance = (self.balance - msg.amount); // Update balance
        require(self.balance >= 0, "Invalid balance");
        let fwd_fee: Int = ctx.readForwardFee(); // Gas checks
        require(ctx.value > ((fwd_fee + 2 * self.gasConsumption) + self.minTonsForStorage), "Invalid value - Burn");
        // Burn tokens
        send(SendParameters{
                to: self.master,
                value: 0,
                mode: SendRemainingValue,
                bounce: true,
                body: TokenBurnNotification{
                    query_id: msg.query_id,
                    amount: msg.amount,
                    sender: self.owner,
                    response_destination: msg.response_destination!!
                }.toCell()
            }
        );
    }

     fun msg_value(value: Int): Int {
        let msg_value: Int = value;
        let ton_balance_before_msg: Int = (myBalance() - msg_value);
        let storage_fee: Int = (self.minTonsForStorage - min(ton_balance_before_msg, self.minTonsForStorage));
        msg_value = (msg_value - (storage_fee + self.gasConsumption));
        return msg_value;
    }

    bounced(msg: bounced<TokenTransferInternal>){
        self.balance = (self.balance + msg.amount);
    }

    bounced(msg: bounced<TokenBurnNotification>){
        self.balance = (self.balance + msg.amount);
    }

    get fun get_wallet_data(): JettonWalletData {
        return
            JettonWalletData{
                balance: self.balance,
                owner: self.owner,
                master: self.master,
                code: initOf JettonDefaultWallet(self.owner,
                    self.master,
                    self.isSendFee,
                    self.feeReciver,
                    self.feeRate
                ).code
            };
    }
}